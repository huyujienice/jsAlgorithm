# 乘方，对数，开方[三级运算]

简介https://www.zhihu.com/question/28092068

a 底数 n 指数 b 幂  
求乘方:  
$
a^n=b    
$  
求对数:  
$
n=log_a^b
$  
求开方:  
$
a=\sqrt[n]{b}
$  
举例:  
$
2^3=8    
$  
$
3=log_2^8   
$  
$
2=\sqrt[3]{8}     
$

```js
// js中求乘方
const a = 2 ** 3;
console.log(a); //-> 8

// 平方根
const b = Math.sqrt(9); //->3


// 2为指数求开方
const c = Math.log2(a); //->3
```

# 时间复杂度

时间复杂度大 O 符号表示法:  
算法的时间复杂度不是指精确算法的执行时间，因为执行时间跟数据规模也有很大关系，时间复杂度只是反映了算法执行时间与数据规模之间的增长关系，即反应了一个时间增长趋势  
时间复杂度跟算法中基本操作重复执行的次数（频度）有关系

1. O(1):常数阶  
2. O(log n):对数阶->二分搜索法（二分搜索法省略底数 2，其时间复杂度为$log_2^n$）  
3. O(nlog n):线性对数阶->归并排序算法,快速排序算法最好     
4. O(n):线性阶  
5. O(n ** 2):平方阶->冒泡排序算法，快速排序算法最坏         
6. O(2^n):指数阶->二叉树遍历算法           
7. O(n!):阶乘阶->穷举算法

常见的算法时间复杂度由小到大依次为：Ο(1)＜ Ο(log n)＜ Ο(n)＜ Ο(nlog n)＜ Ο(n2) ＜ Ο(2^n)＜ Ο(n!)

快速排序平均时间复杂度 O(nlog n),最坏情况 O(n \*\* 2)    

1. 最好时间复杂度
2. 最坏时间复杂度
3. 平均时间复杂度
4. 均摊时间复杂度    
一般讲复杂度都是讲最坏时间复杂度，因为其给出了一个效率安全值           

```js
// O(logn)算法举例
const a = (n) => {
  let i = 0;
  while (i < n) {
    i *= 2;
  }
};
// O(nlogn)算法举例
const b = (n) => {
  for (let j = 0; j < n; j++) {
    let i = 0;
    while (i < n) {
      i *= 2;
    }
  }
};
```

# 空间复杂度

一个程序的空间复杂度是反映运行内存空间大小与数据规模增长之间的增长关系     

通过时间复杂度和空间复杂度，来评价一个算法的优劣，即是否“快”“省”

# 数据结构

## 线性结构

栈，队列，链表，线性表

### 数组

类列表对象

Array.from()  
对一个类数组（arguments）或可迭代对象（Map 或 Set）创建新的，浅拷贝的数组实例。  
Array.isArray()  
用来判断某个变量是否是一个数组对象  
Array.of()  
根据一组参数来创建新的数组实例，作用类似字面量写法[]
Array.prototype.length  
数组中的元素个数，可以通过直接设置 lenght 实现截断数组  
Array.prototype.concat()  
返回一个新数组，用于合并两个或者多个数组，不会更改现有数组  
Array.prototype.copyWithin()  
改变原有数组，但是原有数组长度不改变，浅复制数组的一部分到同一个数组的另一个位置
Array.prototype.entries()  
返回新的 Array Iterator 对象，该对象包含数组中每个索引的键值对
Array.prototype.every()  
返回一个布尔值，测试一个数组内所有元素是否都能通过某个指定函数的测试
Array.prototype.fill()  
改变原有数组，用一个固定值填充一个数组从起始索引到终止索引内的全部元素。不包括终止索引  
Array.prototype.filter()  
返回一个新数组，其包含通过所提供的函数实现的测试的所有元素  
Array.prototpye.find()  
返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined  
Array.prototype.findIndex()  
返回数组中满足提供的测试函数的一个元素的索引，若没有找到对应元素则返回-1  
Array.protopype.findLast()  
返回满足提供的测试函数条件的最后一个元素的值，否则返回 undefined  
Array.prototpye.findLastIndex()  
返回满足提供的测试函数条件的最后一个元素的索引，若没有找到对应元素则返回-1
Array.prototype.flat()  
返回新数组，按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组的元素合并为一个新数组返回  
Array.prototype.flatMap()
Array.prototype.forEach()  
对数组的每个元素执行一次给定的函数  
Array.prototype.includes()  
返回 true 或 false,用来判断数组是否包含一个指定的值  
Array.prototype.indexOf()  
返回索引，返回在数组中找到一个给定元素的第一个索引，如果不存在则返回-1  
Array.prototype.join()  
返回字符串，将一个数组的所有元素连接成一个字符串并返回，所有数组元素被转换成字符串，再用一个传入的分隔符将这些字符串连接起来  
Array.prototype.keys()  
返回索引键的迭代器对象  
Array.prototype.lastIndexOf()  
返回索引值，返回指定元素在数组中的最后一个的索引，不存在则返回-1  
Array.prototype.map()  
返回新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成  
Array.prototype.pop()  
返回数组中的元素，从数组中删除最后一个元素，并返回其值，且会更改原数组  
Array.prototype.push()  
返回数组长度，将一个或者多个元素添加到数组的末尾，并返回该数组的新长度,会更改原数组  
Array.prototype.reduce()  
返回函数调用值，对数组中的每个元素按序执行一个提供的函数，每次运行此函数将会将之前的计算结果作为参数传入，最后将其结果汇总为单个返回值,reduce((a,b)=> a + b) 即返回数组内所有元素相加和  
Array.prototype.reduceRight()  
返回函数调用值，使用方法与 reduce()类似，不过执行顺序为从尾到头，从右到左  
Array.prototype.reverse()  
返回原数组，数组中元素位置颠倒，会改变原数组  
Array.prototype.shift()  
返回删除的值，从数组中删除第一个元素，并返回该元素的值，会更改原数组  
Array.prototype.slice()  
返回新数组，这个数组是一个由 begin 和 end 决定的原数组的浅拷贝，不改变原数组  
Array.prototype.some()  
返回 true 或 false，测试数组中是不是至少有 1 个元素通过了被提供的函数测试  
Array.prototype.sort()  
返回原数组，用原地算法进行排序，然后返回，改变原数组，sort((a, b) => a - b) 就是升序排列  
Array.prototype.splice()  
返回原数组，通过删除或者替换或添加新的元素来修改数组  
Array.prototype.toLocaleString()  
返回一个字符串表示数组中的元素  
Array.prototype.toString()  
返回一个字符串，表示指定的数组及其元素  
Array.prototype.unshift()  
返回数组长度，将一个或者多个元素添加到数组的开头，会更改原数组  
Array.prototype.values()  
返回索引值的迭代器对象

### Set

Set 对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素是唯一的。
+0，-0 算相同值  
NaN 与 NaN 算相同值  
undefined 与 undefined 算相同值

Set 无法获取集合内单独的一个元素

### Map

Map 对象保存键值对，并且能够记住键的原生插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值

### 链表

用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个对象的地址。  
(线性存储节点，节点包括自身的值和下一个节点的指向)  
特点：插入快，查询慢  
例如：原型链

## 非线性结构

二维数组，树

### 堆与优先队列（heap）

数组可以代表一颗完全二叉树

#### 大顶堆小顶堆

父节点永远大于等于左右子节点，即大顶堆  
父节点永远小于等于左右子节点，及小顶堆

堆适合维护：集合最值  
大顶堆可用于维护前 n 小元素，因为大顶堆弹出的是集合内最大的
小顶堆可用于维护前 n 大元素，因为小顶堆弹出的是集合内最小的

### 树

树通常用来存储逻辑关系为一对多的数据，树是用来模拟具有树状结构性质的数据集合

#### 结点

树存储结构中也将存储的各个元素称为“结点”

1. 父结点
2. 根结点
3. 叶结点

#### 子树

通常，我们将一棵树中几个节点构成的“小树”称为这棵树的“子树”

#### 结点的度

一个结点拥有的子树的个数，就称为该结点的度（Degree）  
比较一棵树中所有结点的度，最大的度即为整棵树的度

#### 结点的层次

从一棵树的树根开始，树根所在的层为第一层，树的孩子结点所在的层为第二层，以此类推  
树中节点层次的最大值，称为这棵树的深度或者高度

### 有序树和无序树

如果一棵树中，各个结点左子树和右子树的位置不能交换，那么这棵树就称为有序树。反之则为无序树

### 二叉树

满足以下两个条件的树就是二叉树：

1. 本身是有序树
2. 每个节点最多有两个子节点

#### 二叉树的性质

#### todo

1. 二叉树中，第 i 层最多有 2\*\*(i-1) 个节点
2. 如果二叉树的深度为 K，那么此二叉树最多有 2\*\*K - 1 个结点
3. 二叉树中，终端结点树（叶子结点树）为 n0，度为 2 的结点数为 n2，则 n0=n2+1

结论 3 推导：n 个结点的数，一定有 n-1 条边  
假设 n0 表示度为 0 的结点树，n1 为度为 1 的结点树，n2 为度为 2 的结点树，那么  
n0+n1+n2 = n1 + 2\*n2 + 1,即 n0=n2+1  
二叉树中知道了叶子结点的数目，那么就知道了度为 2 的结点数目

#### 二叉树遍历

1. 前序遍历：访问根->遍历左子树->遍历右子树
2. 中序遍历：遍历左子树->访问根->遍历右子树
3. 后序遍历：遍历左子树->遍历右子树->访问根
4. 广度遍历：按照层次一层层遍历

前根左右，中左根右，后左右根  
前中后代表的是根结点的位置

知道中序遍历+前/后序遍历可推导出二叉树结构  
因为前/后序遍历可直接知道根结点，中序遍历知道根结点后可知道左中序结点和右中序结点的个数，  
即可知道左前结点和右前结点或者左后结点或右后结点的内容，递归推导即可获取整个二叉树结构

前 1 2 4 9 5 6 10 3 7 8
中 4 9 2 10 6 5 1 3 8 7

2 4 9 5 6 10
4 9 2 10 6 5

4 9

5 6 10
10 6 5

6 10
10 6

3 7 8
3 8 7

7 8
8 7

               1
            2       3
         4    5        7
          9  6        8
            10

### 完全二叉树

#### 完全二叉树特点

当根结点为 1 的时候 1.编号为 i 的子节点，左孩子编号为 2*i,右孩子编号为 2*i+1  
2.可以用连续空间存储（数组）

### 二叉排序树

二叉排序树又被称为二叉搜索树或二叉查找树

#### 特征

1.若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值  
2.若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值  
3.它的左，右子树分别为二叉排序树

（左子树小于根，右子树大于根）
二叉排序树中序遍历的结果是一个升序的序列

#### 线段树

线段树是用来维护区间信息的数据结构

# 动态规划

动态规划类似数学归纳法  
给定一个问题，把它拆成一个个子问题，知道子问题可以直接解决。然后把子问题答案保存起来，已减少重复计算。再根据子问题答案进行反推，得出原问题解的一种方法。

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划  
如：最长递增子序列，最小编辑距离，背包问题，凑零钱问题等

约瑟夫环->DP 解法  
总成员 n,出局者从 0 开始第 m 个,状态转移方程为:  
f(n) = (f(n-1) + m) % n 即

```
function f(n,m){
   if(n===1)return 0
   return (f(n-1,m)+m)%n
}
```
# 归并排序
基于分治策略（将问题分成一些小问题然后递归求解，治阶段将分阶段得到的答案修补在一起，即分而治之）          
基本思想：将数组分为A,B两组，如果A,B两组是有序的，可以通过双指针将两组有序的数组合并成一组有序数组         
如何保证A,B有序？将A,B继续分组，以此类推，当分出的小组只有一个数据的时候是有序的，再将相邻的小组进行合并     

### 外部排序，多路归并排序  
外部排序一般指大文件排序，即待排序的记录存储在外存储器上，待排序的文件无法一次性装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的    
外部排序最常用的算法是多路归并排序    
举例：
1. 10G的排序数据，1G的内存，先将10G的文件分成10份1G的数据，分别存入内存进行排序，这样就得到了10份1G的有序数据     
2. 使用10个指针在10份数据中每次选取最合适的数据，将其取出存入外存，其指针指向下个数据（升序排序，从10个指针中选择数据Math.min，指针++）       

# 快速排序
基于分治策略
基本思想：选取数组中某个元素作为“基准数”，将左右小于基准数的元素移动到基准数左边，将大于基准数的值挪到右边，在递归对左右两个子数组进行排序      

# 选择排序
开启循环，取出未排序区间内最小元素，加入已排序区间末尾    

# 冒泡排序
循环连续比较未排序区间相邻元素，左比右大就交换。从数组从右往左遍历，每轮循环即可将最大值挪动到最右边        
优化：新增标识位，当某轮循环未执行交换操作说明已完成排序，可以break         

# 贪心算法

在每个决策的阶段，都选择当前看起来的最优解，及贪心地做出局部最优的决策，以期获得全局最优解  
贪心算法效率高，但是有可能无法保证找到全局最优解，并且有可能找到非常差的解。对于这种情况可尝试动态规划(DP)解决

# DFS & BFS

# 前缀和

当涉及区间和，前缀和为首选方案，子数组即为数组的区间表示  
通常对于连续子数组的处理为双指针和滑动窗口，但当没有明确的指针移动判断条件时，可以尝试使用前缀和算法

# 滑动窗口

优化子数组和字符串的问题  
TCP 滑动窗口协议，网络数据传输流量控制，避免拥堵发生

# 双指针

双指针技巧适用于数组和字符串的遍历与查找问题，尤其是在需要高效处理对称性或前后关系时

# 拓扑排序

# random

Math.random() -> [0,1)  
Math.floor(Math.random() * 3) -> 0,1,2  
Math.floor(Math.random() * 3 + 10) -> 10,11,12
