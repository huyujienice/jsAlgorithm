# OSI七层网络模型  
Open System Interconnect,开放式系统互联

## 应用层
为应用程序提供服务  
HTTP协议，超文本传输协议，它允许将超文本标记语言HTML文档从web服务器传送到客户端的浏览器    

### HTTP协议结构
客户端发出的消息称为HTTP请求，服务端返回的消息称为HTTP响应  

#### HTTP请求消息结构
1. 请求行：分别是请求方法+空格+URL+空格+协议版本+\r\n  
2. 请求头：由多个请求头键值对组成，中间以冒号：隔开，每个键值对最后是\r\n  
3. 空行：即\r\n  
4. 请求包体：包体部分  

#### HTTP响应消息结构
1. 状态行：分别是协议版本+空格+状态码+空格+状态码描述符+\r\n  
2. 响应头：由多个响应头部键值对组成，中间以：隔开，每个键值对最后是\r\n  
3. 空行：即\r\n  
4. 响应包体：包体部分  

### HTTP请求方法
1. GET:获取指定页面信息  
2. HEAD:类似GET请求，但响应中没有具体内容，只有响应Header  
3. POST:向指定URL提交信息  
4. PUT:向服务器传送数据  
5. DELETE:请求服务器删除指定内容  
6. OPTIONS:查看服务器信息  
7. TRACE:回显服务器收到的请求，主要用于测试和诊断  
8. PATCH:是对PUT方法的补充，用来对已知资源进行局部更新  
9. CONNECT:HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器  

#### GET和POST区别
1. 数据位置，GET传参附加在url上，POST传参附加在Body上
2. 数据长度限制，GET由于在url上传参，url有长度限制，POST没有
3. 数据安全性，GET在url上能看得到，POST看不到
4. 缓存，GET会被浏览器缓存，POST不可缓存   

GET和POST都属于HTTP请求方法，没有本质区别，只是一种规范     
有个浏览器级别的区别就是，GET产生一个TCP数据包，POST产生两个TCP数据包        

### HTTP状态码
1. 1xx:服务器收到请求，需要请求者继续执行操作
2. 2xx:成功
3. 3xx:重定向
4. 4xx:客户端错误
5. 5xx:服务器错误
例：
101:协议切换，比如切换websocket协议     
301:永久重定向     
302:临时重定向        
304:未修改，可使用协商缓存      
401:要求用户授权      
431:请求头太大    

### HTTP content-type
文件类型，决定浏览器以什么形式，什么编码读取这个文件（有些网页点击结果下载图片或者文件的原因）    
MIME类型是描述消息内容的标准，用来表示文档，文件或字节流的性质和格式       
通用结构：type/subtype      
例:    
1. text/html:超文本标记语言.html
2. text/plain:普通文本.txt
3. image/gif:GIF图形.gif
4. image/jpeg:JPEG图形.jpeg .jpg
5. application/x-gzip:GZIP文件.gz
6. application/x-tar:TAR文件.tar   
    
设置content-type:application/octet-stream，响应为字节流，浏览器处理字节流的默认方式就是下载    
配合设置Content-Disposition来实现图片文件下载（网页内联还是下载到本地）   
例如：     
Content-Type: application/octet-stream     
Content-Disposition: attachment; filename="picture.png"    



### HTTP URL

┌─────────────────────────────────────────────────────────────────────────────┐
│                                    href                                     │
├──────────┬┬───────────┬─────────────────┬───────────────────────────┬───────┤
│ protocol ││   auth    │      host       │           path            │ hash  │
│          ││           ├──────────┬──────┼──────────┬────────────────┤       │
│          ││           │ hostname │ port │ pathname │     search     │       │
│          ││           │          │      │          ├─┬──────────────┤       │
│          ││           │          │      │          │ │    query     │       │
"  http:   // user:pass @ host.com : 8080   /p/a/t/h  ?  query=string   #hash "
│          ││           │          │      │          │ │              │       │
└──────────┴┴───────────┴──────────┴──────┴──────────┴─┴──────────────┴───────┘


### XSS
Cross-Site Scripting,XSS 代码注入
恶意js脚本上传攻击服务器，或者恶意钓鱼网站进行脚本视觉欺骗等     

如何解决：
1. 不信任客户端操作，业务主流程关键节点校验
2. CSP策略,"内容安全策略"，提供加载外部资源白名单          
### CSRF
Cross-Site Request Forgery,伪造跨站请求

如何解决：
1. 同源检查
    1.1 Origin Header
    1.2 Referer Header

2. CSRF Token
3. 业务主流程关键节点校验     

### 中间人攻击
Man-in-the-middle attack MITM  
公共场所免费wifi,劫持流量

如何解决：
1. https
2. 相互认证
3. 延迟测试，通讯延迟异常则可能存在第三方中间人    


## 表示层  
数据格式转化，数据加密  

## 会话层  
建立，管理和维护会话  

## 传输层  
建立，管理和维护端到端的连接  
建立端口（port）到端口的通信，端口是0到65535之间的一个整数，刚好是16个二进制位，0到1023的端口被系统占用，用户只能选择大于1023的端口。  
Unix系统就把主机+端口，叫做“套接字”（socket），源端口号+ip首部的ip源地址+目的端口号+ip首部的目的ip地址，唯一的确定了tcp连接。   
"套接字"(Socket)是一种在计算机网络中用于实现进程间通信的编程接口(个人感觉类似于后端接口api的概念)   

### tcp协议结构

#### 首部
通常包含20个字节
1. 1-2B（代表第一个到第二个字节）：源端口号  
2. 3-4B:目的端口号  
3. 5-8B:序号，tcp提供全双工服务，两端都有各自的序号。解决网络包乱序问题  
4. 9-12B:确认序列号，上次成功收到的数据字节序号加1，ack为1才有效。解决丢包问题  
5. 13.0-13.5B:6b长度，偏移量  
6. 13.5B-14B:6b长度，保留  
7. 13-14B:标识位，控制各种状态  
8. 15-16B:窗口大小，接收端期望接收的字节数。解决流量控制的问题  
9. 17-18B:校验和，由发送端结算和存储，由接收端校验。解决数据正确性问题  
10 .19-20B:紧急指针  

##### 首部标识位说明
标识符可为01,1表示有效  
1. URG:为1时，表示紧急指针有效    
2. ACK:确认标识，连接建立成功后，总为1。为1时确认号有效    
3. PSH:接收方应尽快把这个报文交给应用层    
4. RST:复位标识，重新连接    
5. SYN:建立新连接标识，建立新连接时，该位为1    
6. FIN:关闭连接标识  

##### TCP连接建立（三次握手）
1. 当新建连接时，客户端到服务端的报文段的SYN位被启用，此时序号字段包含了初始序列号ISN  
2. 服务端返回ACK（确认序号为客户端序号ISN+1）作为确认。同时发送SYN作为应答（序号为内容为服务端唯一序号）  
3. 客户端发送ACK确认收到（确认序号为服务端序号+1）  

##### 为何是三次握手
1. TCP连接时全双工的，数据在两个方向上能同时传递  
2. 要确保双方，同时能发送数据和接收数据  
3. 第一次握手，证明了发送方能发送数据  
4. 第二次握手，ack确保了接收方能接收数据，syn确保了接收方能发送数据  
5. 第三次握手，确保了发送方能接收数据  
6. 建立连接其实是4个维度的信息交换，不过中间两步合并为一次握手了  
7. 4次握手浪费，2次握手不能保证双方同时具备收发功能  
  

##### TCP断开连接（四次挥手）
1. （客户端）主动关闭的一方发送FIN,表示要单方面关闭数据的传输  
2. 服务端接收到FIN后，发送一个ACK作为确认（序列号为收到的序列号+1）  
3. 等服务端传输数据完毕，也发送一个FIN的标识，表示关闭这个方向的数据传输  
4. 客户端回复ACK以确认回复  

##### 为什么是四次挥手
1. TCP连接时全双工的，数据在2个方向上能同时传递  
2. TCP支持半关闭（发送一方结束发送还能接收数据）  
3. 因此每个方向都要单独关闭，且收到关闭通知需要发送确认回复  

TCP三次握手保证双方功能性，四次挥手保证双方传输数据完整性     

##### 为什么要支持半关闭
1. 使用半关闭的单连接效率要比使用两个TCP连接更好


## 网络层  
IP选址及路由选择  
引进一套新的地址，使得我们区分不同的计算机是否属于同一个子网络，这套地址就是“网址”  

### IP协议结构
1. 版本  
占4位，表示IP协议的版本。通信双方使用的IP协议版本必须一致。目前广泛使用的IP协议版本号是4，即IPv4  
2. 首部长度
占4位，这个字段所表示的数的单位是4个字节。因此，当IP的首部长度为1111时，首部长度就达到60个字节  
3. 区分服务  
占8位  
4. 总长度  
占16位，首部和数据之和，单位为字节。总长度为16位，因此数据报的最大长度为2^16-1=65535字节  
5. 标识  
占16位，当数据报的长度超过网络的MTU限制，而必须分片的时候，通过此字段是否相同判断是否需要重组为原来的数据源  
6. 标志  
占3位，第一位未使用，其值为0。第二位称为DF（不分片），标识是否允许分片。取值为0时，表示允许分片；取值为1表示不允许分片。第三位称为MF（更多分片），表示是否还有分片正在传输，设置为0时表示没有更多分片需要发送，或者数据没有分片。  
7. 片位移  
占13位。  
8. 生存时间  
占8位，表示数据报在网络中的寿命  
9. 协议  
占8位，该字段方便目的主机的IP层知道上层传输层使用什么协议。例如，TCP的协议是6，UDP协议是17，ICMP的协议为1  
10. 首部校验和  
占16位，校验首部  
11. 源地址  
占32位，表示数据报的源IP地址  
12. 目的地址  
占32位，表示数据报的目的IP地址  
13. 可选字段  
14. 填充  



## 数据链路层  
提供介质访问和链路管理  
来自线路的二进制数据包称作一个帧
链路中这么多连续01如何分辨哪些是一个帧的信息？
以太网帧结构由前导码和帧开始符开始，冗余校验结尾，每个帧之间都有帧间距  

### 以太网结构  

#### 前同步码
10101010 10101010 10101010 10101010 10101010 10101010 10101010  
7个字节，作用是使接收端的适配器在接收MAC帧时能够迅速调整时钟频率，使它和发送端的频率相同  
#### 帧开始符
10101011  
1个字节  
一个帧已7个字节的前导码和1个字节的帧开始符作为帧的开始，即  
10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101011 
//todo
//没搞清楚16进制为什么转成这样，不应该是0xaa吗？
由于在传输一个字节时最低位最先传输（LSB），因此对应的16进制表示为 0x55 0x55 0x55 0x55 0x55 0x55 0x55 0xD5  
#### 报头,目的MAC地址
6个字节，目的地方的MAC地址，用处是当网卡接收到一个数据帧时，首先会检查该帧的目的地址，是否与当前适配器的物理地址相同，如果相同则进一步处理，不相同则丢弃  
#### 报头，源MAC地址  
6个字节，发送端的MAC地址    
报头包含源地址和目标地址的MAC地址  
#### 类型
2个字节，该字段在网络协议分解中及其重要，PDU（协议数据单元）来到某一层时，它需要将PDU交付给上层，而上层协议众多，所以在处理数据时，必须要一个字段标识我这个交付给谁。  
例如：该字段为0x0800时，表示将有效载荷交付给IP协议，为0x0806交付给ARP，0x8035交付给RARP。
#### 数据
有效负荷，需要交付给上层的数据。数据长度最小为46字节，最大为1500字节  
#### 帧校验码FCS
帧校验码是一个32位循环冗余校验码，以便验证帧数据是否被损坏  
#### 帧间隙
最小12个字节，其数据全为1？
11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111

## 物理层  





### websocket
websocket是基于TCP的一种新的持久化应用层网络协议。它实现了客户端与服务端全双工通信，即服务器主动发送消息给客户端   

特点：   
1. 与HTTP协议有良好兼容性，握手阶段使用HTTP协议进行握手，复用HTTP服务器进行协议升级     
2. 较小的开销，因websocket有状态，建立连接后不需要携带大量状态标识信息       
3. 没有同源政策    

主要流程：    
1. 客户端发起HTTP协议完成单次握手,协议新增请求头       
    1.1 Connection:Upgrade 
    1.2 Upgrade:websocket 
2. 服务端返回101,表示成功建立websocket协议   
3. 全双工websocket通讯     


### HTTP1.1 HTTP2.0 HTTP3.0

http1.1       
1. http1.1基于文本解析，把所有请求和响应作为纯文本    
2. http1.1加入缓处理(强缓存和协商缓存)    
3. http1.1拥有长连接(Connection:keep-alive)        
4. http1.1基于tcp连接     

http2    
1. 不同于http1.1文本传输，http2采用二进制传输，将内容进行分流     
1. 头部字段压缩     
2. 多路复用，同一TCP连接同时并行传输多个HTTP请求和响应，请求数据无序，浏览器组装    
3. 服务端主动推送缓存    

http3     
1. 优化头部压缩     
2. 放弃tcp,通过QUIC(udp)建立，解决了队头堵塞问题等问题      

### Connection: keep-alive和多路复用区别
Connection: keep-alive是顺序处理多个请求      
多路复用可以同时传输多个请求


### 浏览器缓存
浏览器缓存分为4种，当依次查找以下缓存且都没有命中的时候，才会去请求网络
1. service worker
2. memory cache  --内存
3. disk cache  --硬盘
4. push cache  --HTTP2推送缓存


强缓存：不会向服务器发送请求，直接从缓存中读取数据     
1. Expires设置强缓存过期时间
2. Cache-Control设置缓存命令

协商缓存：强缓存失效后，向服务器发送获取资源请求    
HTTP状态码304表示缓存有效，无需更新    
HTTP状态码200表示缓存失效，返回资源结果        
1. Last-Modified和If-Modified-Since:资源更新时间
2. ETag和If-None-Match：资源的唯一标识

### 数据传输安全
可以基于TCP协议实现私有协议通讯?    
Netty   


### 浏览器跨域  

同源政策是浏览器独有核心安全策略，协议，域名，端口号任意不同则非同源    
非同源以下行为收到限制：  
1. Cookie,LocalStorage,IndexDB无法读取   
2. DOM 无法获得   
3. 基于XMLHttpRequest及Fetch的AJAX请求无法获取    

如何解决浏览器跨域问题:  
1. JSONP:通过在html加入script元素，向服务器请求JSON数据，只支持get请求
2. WebSocket
3. CORS:服务端设置响应头Access-Control-Allow-Origin:*


### XMLHttpRequest Fetch

```js
const xhr = new XMLHttpRequest();
xhr.open("GET", "/service");

// state change event
xhr.onreadystatechange = () => {
  // is request complete?
  if (xhr.readyState !== 4) return;

  if (xhr.status === 200) {
    // request successful
    console.log(JSON.parse(xhr.responseText));
  } else {
    // request not successful
    console.log("HTTP error", xhr.status, xhr.statusText);
  }
};

// start request
xhr.send();

```

```js
fetch("/service", { method: "GET" })
  .then((res) => res.json())
  .then((json) => console.log(json))
  .catch((err) => console.error("error:", err));

```

区别：
1. Fetch支持设置浏览器缓存，XMLHttpRequest只能通过附加随机查询字符串绕过浏览器缓存 
2. 服务器未设置Access-Control-Allow-Origin，Fetch和XMLHttpRequest都会失效，但是Fetch有'no-cors'模式，可配合service worker获取静态资源
3. Fetch可设置是否发送cookie,XMLHttpRequst总是发送cookie
4. Fetch可设置是否遵循服务器重定向命令，XMLHttpRequest不可设置
5. Fetch支持流式请求和响应，XMLHttpRequest不支持
6. Fetch不支持获取上传进度，XMLHttpRequest支持
   


